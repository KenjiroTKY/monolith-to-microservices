= マイクロサービスで十分
== マイクロサービスとは？
ビジネスドメインをモデル化した独立してデプロイ出来るサービスのこと。
マイクロサービスアーキテクチャでは複数のマイクロサービスが連携する。
SOAと同様だが、マイクロサービスはテクノロジーに依存しない。
データを含むビジネス機能をカプセル化する。

=== 独立したデプロイが可能（本書で最も重要）
他サービスとの依存なく本番環境にデプロイ出来る。
独立したデプロイを実現するために疎結合が必要である。
例えばデータベースの共有は問題となりうる。
疎結合を実現するためにどうやってサービス境界線を見つければ良いのだろう。

=== ビジネスドメインのモデル化
プロセス境界線の変更は、境界線を新たに作るよりも高コストなので極力避けなければならない。
本書では下記の３層が別々のチームで管理されている実在のシステムを例にする

 1. WebベースのUI層
 2. ビジネスロジックがあるモノリシックなバックエンド層
 3. 古典的なデータベース層

何か変更をする場合は、各層を担当するチームがそれぞれ変更をし正しい順序でデプロイする必要がある。
現在、３層アーキテクチャは悪くはないし世間に広く採用されている。それは、我々の開発組織構造にも原因がある（コンウェイの法則）。
DBエンジニアやフロントエンドエンジニアなど専門職で構成されていたためである。現在は多能工の時代である（手離れやサイロを抑制する）。
３層アーキテクチャは技術的に高凝集だがビジネス的には低凝集である。変更速度を高めるにはビジネス的な凝集を優先すべきである。
（具体例の紹介は割愛）

=== 自分のデータを自分で所有する
データベースを共有してはいけない。
他サービスのデータにアクセスしたければサービスを介してデータをリクエストする。データを提供するサービスは変化しない安定したインタフェースを提供することが重要である。
UI,ロジック,データをカプセル化することでビジネス機能を高凝集化しビジネス機能の変更を容易にする。そのためにデータベースを隠し、疎結合にする。

=== マイクロサービスがもたらす利点はなにか
利点は複数あり、変わり得る。
デプロイの独立性はシステムのスケールとロバスト性を高め、技術の混在と選択を可能にする。
各サービスは並行して作業できる。
サービスの範囲が限定されるので開発者が仕様を理解しやすい。
マイクロサービスは柔軟性を提供する。
これらの利点はタダで手に入るわけではない。マイクロサービスの目的や得たいものによってアプローチは変わってくる

=== マイクロサービスがもたらす課題はなにか
SOAはサーバが安くなったから意味を持つようになった。高価なサーバに全てをデプロイするのではなく、安価なサーバに各サービスをデプロイする。SOAは複数のサーバでアプリケーションを実現することを試みた、ネットワークでコミュニケーションするようになったのが大きな挑戦だ。
ネットワークは即時性がなくレイテンシを考慮する必要がある。
ネットワークレイテンシは変化し、システムのふるまいは予測できない。
ネットワークは時々失敗する（パケットロスやLANケーブル抜け）。
複数サーバから一貫したデータを取得するにはどうすればよいかも課題だ。

=== ユーザインタフェース
マイクロサービスをサーバサイドだけに採用し、UI層をモノリシックにしている事例があるが、新機能を迅速にデプロイしたいのであれば大きな過ちである

=== テクノロジー
マイクロサービスのために新しいテクノロジーを導入する誘惑に駆られるが、誘惑に負けてはいけない。
新しいテクノロジーの導入にはコストがかかる。
マイクロサービスへの移行は今まで経験したことのない挑戦となるだろうからテクノロジーは慣れ親しんだものの方が良い。マイクロサービスではプログラミング言語の選定は重要な事柄ではない。

=== サイズ
マイクロサービスはどのくらいの大きさか？マイクロという言葉に違わない大きさである。
コードの行数で測るものではない。
マイクロサービスのエキスパート Chris Richardsonの言葉 "as small an interface as possible" が筆者の考えに近い。
サイズについて悩まないで欲しい、２つのキーポイントに注力しよう。

 1. いくつのマイクロサービスを管理できるか

サービスが増えれば複雑性が増し新しい技術を学ばなければいけなくなる。
インクリメンタルにマイクロサービスを適用していくことを強く提唱したい。

 2. どのように密結合を避けたマイクロサービスの境界を定めるか

特定のサービスを迅速にデプロイでき、スケールが必要なら他の言語で書き換えられることの出来る"micro-apps"がマイクロサービスの始祖である。サービスのサイズは、数日で書き換えられる程度（自分の頭の大きさ程度）で理解が容易であった。

=== オーナーシップ
マイクロサービスでビジネスドメインをモデル化するとITアーティファクト（独立してデプロイ出来るマイクロサービス）とビジネスドメインが一致するのを見てきた。
この考えはITとビジネスの分断を打破したいテクノロジーカンパニーに響いている。
伝統的なIT組織ではソフトウェアの開発は顧客との接点を持つビジネス部署とは別組織で行なわれてきた。
真のIT組織ではプロダクトオーナーはデリバリーチームの一員として働き、技術のグループよりも顧客と接する部署とより強くアラインしている。
ITリーダーはこの顧客指向のデリバリーチームのサポートをする。
多くの組織はこのような変更が出来ていないがマイクロサービスはこの変更を容易にする。もしデリバリーチームに顧客部署とアラインすることを望み、サービスがビジネスドメインとアラインしているのであれば、このプロダクト指向のデリバリーチームにオーナーシップをアサインすることが容易になる。
複数のチーム間で共有されるサービスを減らすことは、デリバリーの調整を最小化するキーとなる。ビジネスドメイン指向のマイクロサービスは組織的な変更を容易にする。

== モノリス
全ての機能を一緒にデプロイする必要があるのであれば、それはモノリスである。
少なくとも３つのタイプのモノリスがある

 1. シングルプロセスモノリス
 2. 分散モノリス
 3. サードパーティブラックボックスシステム

=== シングルプロセスモノリス
全てのコードがシングルプロセスとしてデプロイされている最も良くあるパターン。本書では特記ない場合はこのタイプをモノリスという。
データベースから読み書きする分散モノリスということも出来る。

==== モジュラーモノリス
シングルプロセスモノリスの派生。
複数の独立に稼働出来るモジュールで構成されているが、デプロイは一括で行なわなければならない。
組織によっては選択の１つと成りうる（Shopifyのような成功例）。
データベースが分解されにくい（密結合される傾向にある）。
データベースをモジュラー毎に分ける構成もある。

=== 分散モノリス
分散モノリスは複数サービスで構成されているが一括でデプロイしなければならない構成。
SOAの定義には合致しているかもしれない。
経験では分散モノリスは分散システムとシングルプロセスモノリスの欠点を全て持っていて、双方の利点も十分に得ていない。

=== サードパーティブラックボックスシステム
マイクロサービスへの移行の中で分解したくなるのでサードパーティのソフトウェアもモノリスである。
ソフトウェアは別の人々によって開発され、我々にはコードを変更することができない。

=== モノリスの挑戦
複数の開発者が同一のコードを触りたかったり、異なるタイミングでリリースしたかったりしたときに誰が何を所有するのか、誰が決断するのか、デリバリーの協議が必要である。
モノリスがマイクロサービスよりデリバリーの協議が必要とは必ずしも言えないが、マイクロサービスは具体的な境界線とオーナーシップを与え、問題を減らすための柔軟性を与える。

=== モノリスの利点
分散システムよりシンプルなデプロイ。
シンプルな開発ワークフロー、モニタリング、問題解析、E2E test。
モノリスの中でのコード再利用の容易さ。

== 結合と凝集（On Coupling and Cohesion）
マイクロサービスの境界を定めるのに重要である。
結合は、一方の変更を他方にどの程度反映しなければならないのかということである。
凝集は、類似したコードをいかにグループ化出来るかということである。

A structure is stable if cohesion is high, and coupling is low.

モノリスでは疎結合は存在しない、何かを変更したら全てをデプロイしなければならない。

=== 凝集
凝集とは、コードが同時に変更され、同時に存在すること。
何かを変更する際に少ないサービスの変更に収まるようになっている状態。

=== 結合
一緒に変更を余儀なくされること。
結合には複数のタイプがあり、別のソリューションが必要。

==== 実装結合
コードが別のコードに依存していて双方を変更しなければならない状態。
例えばデータベースのテーブルを共有している。
致命的な結合だが簡単に減少出来る、例えばサービス化しデータベースのテーブルを隠蔽する、Datatableとして提供するのも良い。
サービスインタフェースをユーザインタフェースと同様に扱おう。
コンシュマーがどのようにサービスを呼びたいのかを最初に考える（"outside-in" thinking）。

==== 一時的な結合
他のサービスに間接的に依存している状態。
例えば、倉庫サービス、注文サービス、顧客サービスがあり、倉庫サービスは注文サービスから、注文サービスは顧客サービスから情報取得しなければならないような状態。
呼ばれる側のサービスが停止していると呼ぶ側のサービスも停止する。
解決策は、キャッシュを持ったり、メッセージブローカーのように非同期更新を採用することである。

==== デプロイ時結合
複数のモジュールが静的リンクされたシングルプロセスのアプリケーション。
何かを変更した際はリンクされたモジュールも含めた全てをデプロイしなければならない。
リリースをうまくやるために、リリーストレインのような計画された繰り返しのプロセスを導入してきた。
デプロイは何かしらのリスクをもたらす。
リスクを減らす方法はたくさんあるが、そのうちのひとつは変更したものだけをリリースすることである。
小さいリリースはリスクも小さくする、何かが間違っていても問題を特定を迅速に簡単にしやすい。
私のマイクロサービスに対する元々の興味は継続的デリバリから来ている、継続的デリバリをしやすいアーキテクチャを求めていた。
デプロイ時結合を減らす方策はマイクロサービスに限らない、例えばErlangのようにホットデプロイ出来るものもある。

==== ドメイン結合
システムが複数の独立したサービスで構成されているときサービスは相互に作用する。
サービス間の相互作用は、ビジネスドメイン間の相互作用であり、ドメイン結合である。
例えば、注文サービスの為には買い物かごの中身を知らなければならない。
決定の為の情報が他のサービスからもたらされることがある。
他のサービスからもたらされる情報が大きすぎる（余分な項目や余分なレコードが含まれる）こともある。
一時的な結合のような３サービス間の関係になっている場合は、２サービス間の情報を再編することで３サービス目を必要としなくなるかもしれない。

== ドメイン駆動設計（DDD）で十分
マイクロサービスアーキテクチャではビジネスドメインでサービスをモデリングすることが重要である。
現実世界に近いようにプログラムを表現したいというのは新しい考えではない。Simulaのようなオブジェクト指向言語は現実世界のモデル化することを実現した。
Eric Evansのドメイン駆動設計は問題のドメインをより良くプログラムに表現する重要な考えを提供した。

=== アグリゲート
DDDではアグリゲートには複数の異なる定義があり混乱する。
アグリゲートとは現実ドメインを表したものと考えている。
アグリゲートはステートマシンのように繰り返すものである。
状態の操作と状態そのものとがグループ化されている。
グループの外から状態の変更はさせない。
アグリゲートは他のアグリゲートと関連性がある。
アグリゲートへの分割方法はたくさんある、メンタルモデルを第一に実装は第二に考える。

=== 境界コンテキスト
境界コンテキストは組織内部の大きな組織的境界を表す。
境界コンテキストは詳細な業務（作業）を隠す、それらは知る必要がないからだ。
実装観点では境界コンテキストは１つ以上のアグリゲートを含む。
アグリゲートによって境界コンテキストは他の境界コンテキストと関係性を持つ、サービスに落とし込むとサービス間の依存関係になる。

=== アグリゲートと境界コンテキストのマイクロサービスへのマッピング
アグリゲートも境界コンテキストもよく定義されたインタフェースを持つ凝集をもたらす。
アグリゲートは単一のドメインに着目した状態を内包するステートマシン、境界コンテキストは連携するアグリゲートの集まりで明確なインタフェースを持つ。
そのため、アグリゲートも境界コンテキストもサービス境界として機能する。
全ての境界コンテキストを内包するサービスを目標にしなければならない。
慣れてきたらアグリゲート境界に沿って分割しよう。
後で分割しても外の世界からは独立して行なうことが出来る、分割は任意の実装のための決定なので出来るだけ隠すべきである。

=== その他の読み物
Eric EvansのDomain Driven Desingn か Vaughn VernonのDomain Driven Design Distilledを読むと良い。

== まとめ
マイクロサービスはビジネスドメインをモデル化した独立してデプロイ可能なサービスである。
サービス同士はネットワークを介してコミュニケーションする。
ドメイン駆動設計によって情報をサービス内に隠し、独立して動作できる安定した境界を持ったサービスを作る。このことで複数の種類の結合を減らす。